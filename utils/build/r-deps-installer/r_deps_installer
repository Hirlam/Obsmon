#!/usr/bin/env Rscript
# Scans the current directory recursively looking for files containing
# R code. Parse these files to identify used libraries. Determine and
# install these packages and their dependencies.
#
# We don't want to use any package for this, as the whole idea
# is that this script should not depend on any non-base package
# at all (you don't want to have to install packages before being
# able to run a package installer)

# List here R-libraries that can be ignored
# pkgsSafeToIgnore: Will be ignored altogether
# excludeFromSuggests: Will be ignored only if listed as type "suggests".
#                      Use this, e.g., for optional libraries that prove
#                      tricky to install.
pkgsSafeToIgnore <- c("RadarBE")
excludeFromSuggests <- c(
  "sf", "units", "udunits2", "vdiffr",
  "freetypeharfbuzz", "RPostgreSQL"
)

# Some rudimentary parsing of command line options
args <- commandArgs(trailingOnly=FALSE)
getArgVal <- function(argName, default=NULL) {
  argPatt <- paste(argName, "={1}", sep="")
  argStr <- grep(argPatt, args, value=TRUE)

  if(length(argStr)==0) argVal <- default
  else {
    argVal <- gsub(argPatt, "", argStr)
    if(anyNA(argVal) | argVal=="") argVal <- NULL
  }
  return(argVal)
}

showDepsAndQuit <- "--listdeps" %in% args
ignoreBuildFail <- "--ignore-build-fail" %in% args
buildOnly <- "--build" %in% args # Just build, do not install
rebuildAll <- "--rebuild-all" %in% args
# --ignore-suggests-deps: Should we skip building/installing "Suggests"-type
#                          dependencies? Default is FALSE.
ignoreSuggests <- "--ignore-suggests-deps" %in% args
# Options that control whether downloads can be made from CRAN or not
# --reset-local-repo will erase everything you currently have in your local repo and
#                    then download new versions of the packages from CRAN. Be careful.
resetLocalRepo <- "--reset-local-repo" %in% args
allowSrcDownload <- "--allow-downloads" %in% args | resetLocalRepo
# --pedantic: Requires all srcs to be present, even if pre-compiled binaries are
#             available. Builds all missing binaries.
pedanticBuild <- "--pedantic" %in% args
# --local-install: Install R-libs to a local R-repo instead of the global one.
#                  Provides minimum interference with the current R setup.
# --local-reinstall: Similar to --local-install, but the locally installed R-libs
#                    are erased first. Useful for updates.
localReinstallRequested <- "--local-reinstall" %in% args
localInstallRequested <- "--local-install" %in% args || localReinstallRequested
# Optional user-specified workDir
workDirUserArg <- getArgVal("--workdir")
# Path to the local R library directory (relative to workDir)
# (to replace the default localRLibDir, optionally)
localRLibDirUserArg <- getArgVal("--local-R-lib-dir")
# Options to be passed to the configure.args argument of install.packages.
# Usage example: ./install -configure.args="--with-udunits2-include=/usr/include/udunits2"
installPkgsConfigArgs <- getArgVal("-configure.args")
installPkgsConfigVars <- getArgVal("-configure.vars")

# Some defaults for installPkgsConfigArgs
# The udunits2 R-lib requires sometimes a bit of a special handling. Providing
# a reasonable default for configure.args in this case.
if(
  !isTRUE(grepl("--with-udunits2-include", installPkgsConfigArgs)) &&
  file.exists("/usr/include/udunits2")
) {
  installPkgsConfigArgs <- paste(installPkgsConfigArgs,
    "--with-udunits2-include=/usr/include/udunits2"
  )
}

# Getting file path and defining workDir
thisFileRelPath <- getArgVal("--file")
thisFileDir <- normalizePath(dirname(thisFileRelPath))
thisFileName <- basename(thisFileRelPath)
thisFileAbsPath <- file.path(thisFileDir, thisFileName)
# Accounting for the fact that the script may be executed via a symlink
thisFileRealPath <- normalizePath(thisFileAbsPath)
thisFileRealDirPath <- normalizePath(dirname(thisFileRealPath))
workDir <- thisFileDir
if(!is.null(workDirUserArg)) workDir <- normalizePath(workDirUserArg)
setwd(workDir)

tmpDirForBuild <- normalizePath(tempdir())
includeDirR <- file.path(thisFileRealDirPath, "include", "R")
source(file.path(includeDirR, "getSysInfo.R"))
source(file.path(includeDirR, "dependencies.R"))
source(file.path(includeDirR, "getExplicitlyUsedRPkgs.R"))
source(file.path(includeDirR, "handleInstallFailure.R"))
source(file.path(includeDirR, "auxFileFunctions.R"))
source(file.path(includeDirR, "binFilesAuxFunctions.R"))

sysInfoStringShort <- getSysInfo()
sysInfoStringLong <- getSysInfo(includeSysName=TRUE, includeSysRelease=TRUE)

localRLibDir <- file.path(workDir,"utils", "build", "local_R_library")
if(!is.null(localRLibDirUserArg)) {
  localRLibDir <- file.path(workDir, localRLibDirUserArg)
}
pkgSrcDir <- file.path(localRLibDir, "src", "contrib")
localInstallRLib <- file.path(localRLibDir, "R-libs")
# Setup of the installer's search for pre-compiled binaries
# Do not mix binaries compiled with versions of R with different major.minor
# This means that R-libs compiled with R version M.m.p will be accepted during an
# install using R version M.m.x (for any p and x), but will not be considered valid
# if either M or m changes.
rVersion <- paste0(version$major, '.', gsub("\\..", "", version$minor))
preCompiledPkgsDirComplement <- file.path(sysInfoStringLong, paste0("R_", rVersion))
localPreCompiledPkgsDir <- file.path(localRLibDir, "pre_compiled", preCompiledPkgsDirComplement)
envVarPreCompiledPkgsDir <- file.path(
  unlist(strsplit(Sys.getenv("R_LIBS_BIN_REPO_ROOTDIR"), ":")),
  preCompiledPkgsDirComplement
)

if(resetLocalRepo) {
  cat(paste0('WARNING: Flag "--reset-local-repo" passed.\n',
    '         The local R source repo will be reset using CRAN!\n'
   ))
  unlink(pkgSrcDir, recursive=TRUE)
}
# Initialising local repo if it doesn't exist
# This could be either because it's the first time the install
# script is run, or because resetLocalRepo is TRUE
if(!dir.exists(pkgSrcDir)) {
  dir.create(pkgSrcDir, recursive=TRUE)
  file.create(file.path(pkgSrcDir, "PACKAGES"))
}

# Remove locally installed R-libraries if localReinstallRequested
if(localReinstallRequested) {
  cat(sprintf(
    'Option "--local-reinstall" passed.\n  > Resetting directory %s\n',
    localInstallRLib
  ))
  unlink(localInstallRLib, recursive=TRUE)
}

remoteRepo <- c("https://ftp.acc.umu.se/mirror/CRAN")
localRepo <- c(file.path("file:", localRLibDir))
# Configuring library search paths
originalLibPaths <- .libPaths()
.libPaths("")
if(localInstallRequested) {
  lib <- localInstallRLib
} else {
  .libPaths(originalLibPaths)
  userRLib <- Sys.getenv("R_LIBS_USER")
  if(userRLib=="") userRLib <- file.path(Sys.getenv("HOME"), "R", "library")
  lib <- userRLib
}
lib <- path.expand(lib)
tmpLibForBuild <- file.path(tmpDirForBuild, "temp_R_lib")
newLibPaths <- unique(c(localInstallRLib, lib, tmpLibForBuild, .libPaths()))
for (dir in newLibPaths) if(!dir.exists(dir)) dir.create(dir, recursive=TRUE)
.libPaths(newLibPaths)
cat("Directories in the R library search path (in order of priority):\n")
for(dir in .libPaths()) {
  cat(paste("  >", dir, "\n"))
}
cat("\n")

if(!dir.exists(localPreCompiledPkgsDir)) dir.create(localPreCompiledPkgsDir, recursive=TRUE)

cat('Gathering R-libraries used in the ".R" files in current dir and subdirs...')
# These may have been imported explicitly using "library" or "require",
# or used without explicit import (double-colon syntax).
allFiles <- list.files(path=".", recursive=TRUE, full.names=TRUE)
allFiles <- allFiles[!grepl(basename(localInstallRLib), allFiles)]
# The local R library will certainly contain R files, but we wil handle those
# via the "dependencies" function
allRFiles <- allFiles[filesAreR(allFiles)]
mainPkgs <- getExplicitlyUsedRPkgs(allRFiles)

cat("Done.\n  > The following",length(mainPkgs),"main R-libraries were found:\n")
for (pkg in mainPkgs) {
  cat("    *", pkg, "\n")
}

cat("\n")
cat("Getting recursive dependency list: \n")
# Doing this manually because we've had too many problems with somewhat erratic
# behaviour of the install.packages own dependency resolution
pkgsDeps <- list()
# Having separate lists with the names of essential R-libs and libs that
# are only needed as "Suggests"-type dependencies (and recursive dependencies
# of these) will allow us, later on, to decide what to do in case a package
# fails to be installed
allEssentialDeps <- c()
allSuggestsDeps <- c()
allDepsNeededBySuggests <- c()
allPkgDeps <- c()
essentialDepsTypes <- c("Depends", "Imports", "LinkingTo")

availablePkgsLocalRepo <- available.packages(repos=localRepo)
availablePkgsRemoteRepo <- tryCatch(
  available.packages(repos=remoteRepo),
  warning=function(w) {
  if(allowSrcDownload) {
    msg <- sprintf(
      "WARN: Could not read available packages from <%s>\n",
      remoteRepo
    )
    msg <- paste0(msg, sprintf("      %s\n", w$message))
    cat(msg)
  }
    return(NULL)
  }
)

# Build a database "pkgsDbToGetDepsFrom" with info about available packages.
# This will be used to resolve dependencies. Start with info about packages
# available in the local CRAN-like repo (if any) and then complement it with
# info obtained from CRAN (if possible). Not updating from CRAN info on packages
# that already exist in the local repo.
availablePkgsRemoteMinusLocal <- availablePkgsRemoteRepo[
  !(rownames(availablePkgsRemoteRepo) %in% rownames(availablePkgsLocalRepo)),
]
pkgsDbToGetDepsFrom <- rbind(
  availablePkgsLocalRepo,
  availablePkgsRemoteMinusLocal
)

# Working out dependencies
for (pkg in mainPkgs) {
  cat("  >", pkg, "... ")
  essentialDeps <- dependencies(pkg, db=pkgsDbToGetDepsFrom,
                     levelOneDepsType=essentialDepsTypes
                   )
  suggestsDeps <- dependencies(pkg, db=pkgsDbToGetDepsFrom, levelOneDepsType="Suggests")
  suggestsDeps <- suggestsDeps[!(suggestsDeps %in% excludeFromSuggests)]

  # A Suggests type dependency may also end up being a recursive non-suggests
  # dependency of the essential R-libraries. We don't want to have these
  # considered as optional.
  suggestsDeps <- suggestsDeps[!(suggestsDeps %in% essentialDeps)]

  # Now, we have to account for the fact that some suggests-type dependencies
  # have themselves some imports, linkingTo, etc that should be installed if
  # we decide to install such suggests deps. These cannot be ignored.
  depsNeededBySuggests <- dependencies(
    suggestsDeps,
    db=pkgsDbToGetDepsFrom, levelOneDepsType=essentialDepsTypes
  )
  depsNeededBySuggests <- depsNeededBySuggests[!(
    depsNeededBySuggests %in% c(essentialDeps, suggestsDeps)
  )]

  pkgsDeps[[pkg]] <- list(
    essential=essentialDeps,
    Suggests=suggestsDeps,
    neededBySuggests=depsNeededBySuggests
  )

  if(ignoreSuggests) {
    thisPkgDeps <- pkgsDeps[[pkg]][["essential"]]
  } else {
    thisPkgDeps <-c(
      pkgsDeps[[pkg]][["essential"]],
      pkgsDeps[[pkg]][["Suggests"]],
      pkgsDeps[[pkg]][["neededBySuggests"]]
    )
  }


  newDeps <-setdiff(thisPkgDeps,intersect(thisPkgDeps,c(mainPkgs, allPkgDeps)))
  cat("nDependencies =", length(thisPkgDeps), "(", length(newDeps),"new)\n")
  allEssentialDeps <- c(allEssentialDeps, pkgsDeps[[pkg]][["essential"]])
  allSuggestsDeps <- c(allSuggestsDeps, pkgsDeps[[pkg]][["Suggests"]])
  allDepsNeededBySuggests <- c(allDepsNeededBySuggests,
    pkgsDeps[[pkg]][["neededBySuggests"]]
  )

  allPkgDeps <- c(allPkgDeps, allEssentialDeps)
  if(!ignoreSuggests) allPkgDeps <- c(allPkgDeps, allDepsNeededBySuggests, allSuggestsDeps)
}
# At last, building the full list of pkgs to be installed
allPkgs <- unique(c(allPkgDeps, mainPkgs))
allEssentialDeps <- unique(allEssentialDeps[!(allEssentialDeps %in% mainPkgs)])
allSuggestsDeps <- unique(
  allSuggestsDeps[
    !(allSuggestsDeps %in% c(allEssentialDeps, mainPkgs))
  ]
)
allDepsNeededBySuggests <- unique(
  allDepsNeededBySuggests[
    !(allDepsNeededBySuggests %in% c(allEssentialDeps, allSuggestsDeps, mainPkgs))
  ]
)


# Notifying user about what deps will be installed
if(length(c(allEssentialDeps, allSuggestsDeps, allDepsNeededBySuggests))>0) {
  cat("\n")
  msg <- "In addition to the main R-libraries listed above,"
  msg <- paste(msg, "the following dependencies should also", sep=" ")
  msg <- paste(msg, "be available after a successful full install:\n", sep="\n")
  cat(msg)
  if(length(allEssentialDeps)>0) {
    cat("* Essential dependencies of the main libraries:\n")
    for (pkg in sort(allEssentialDeps)) cat("  >", pkg, "\n")
  }

  if(length(allSuggestsDeps)>0) {
    if(ignoreSuggests) {
      cat(
        '* The following "Suggests"-type dependencies will be skipped (please\n',
        '  rerun the install script with the --include-suggests-deps option\n',
        '  if you really wish them to be included):\n'
      )
    } else {
      cat('* Suggests-type dependencies:\n')
    }
  }
  for (pkg in sort(c(allSuggestsDeps, allDepsNeededBySuggests))) cat("  >", pkg, "\n")
}

cat("Total:", length(allPkgs), "R-libraries to be built/installed.\n")
cat("  Main R-libraries:", length(mainPkgs), "\n")
cat("  Essential dependencies for the main R-libs:", length(allEssentialDeps), "\n")
if(ignoreSuggests) {
  cat(
    "  Suggests-type dependencies have *NOT* been included.\n",
    "    > Use the --include-suggests-deps option if you wish them to be.\n"
  )
} else {
  cat('  Suggests-type dependencies:', length(allSuggestsDeps), "\n")
  cat(
    "  Extra deps needed to install the suggests-type deps:",
    length(allDepsNeededBySuggests), "\n"
  )
}
cat("\n")

if(showDepsAndQuit) {
  cat('Option "--listdeps" passed. Not installing R-libraries. \n')
  cat('Stopping now.\n')
  quit()
}

# Checking what needs to be done
installedPkgs <- installed.packages(lib.loc=lib)[,1]
pkgsToBeUpdated <- rownames(old.packages(lib.loc=lib, repos=localRepo))
pkgsToBeInstalledMask <- !(allPkgs %in% installedPkgs)
pkgsToBeInstalledMask <- pkgsToBeInstalledMask | (allPkgs %in% pkgsToBeUpdated)
pkgsToBeInstalled <- allPkgs[pkgsToBeInstalledMask]
# If the "--pedantic" command line option is passed, then the script will
# require that the repo contains all source files for the R-libs used in
# the code, even if they are already installed in the system.
# This is to ensure that distributing the code as part of a package (such
# as an RPM, for instance) is done in a consistent fashion.
#
# If that command line option is not passed, then the script will only require
# the existence of sources for R-libraries that are not yet installed.
srcsReqInRepo <- pkgsToBeInstalled
if(pedanticBuild | rebuildAll) srcsReqInRepo <- allPkgs

if(allowSrcDownload) {
  errMsgSolveMissingPkgs <- paste(
    '>>> Could not find missing package(s) on CRAN!\n',
    '    Please double-check that the package names are correct.'
  )
} else {
  errMsgSolveMissingPkgs <- paste(
    '>>> If you wish the missing sources to be downloaded automatically, please\n',
    '    run the installation script with the option "--allow-downloads'
  )
}
errMsgSolveMissingPkgs <- paste(
  errMsgSolveMissingPkgs,
  '\n \n',
  "You can also manually add the missing package tarballs to the\n",
  pkgSrcDir, "\n",
  "directory, go to that directory, open R, run\n",
  "    tools::write_PACKAGES() \n",
  '    db = read.dcf("PACKAGES") \n',
  '    saveRDS(db, "PACKAGES.rds") \n',
  "to update the repo, and try again.\n"
)

missingSrcsReqPkgs <- srcsReqInRepo[!(srcsReqInRepo %in% rownames(availablePkgsLocalRepo))]
if(length(missingSrcsReqPkgs)>0) {
  # Deciding whether or not to download needed source files that are missing.
  errMsg <- "The local R repo does not contain all required sources!\n"
  errMsg <- paste0(errMsg, sprintf(
    "Sources are missing for the following %d R-libraries:\n",
    length(missingSrcsReqPkgs))
  )
  for(pkgName in missingSrcsReqPkgs) {
    errMsg <- paste(errMsg, "  >", pkgName, "\n")
  }

  downloadedPkgs <- c()
  if(allowSrcDownload) {
    errMsg <- paste(errMsg, "Missing sources will be downloaded from CRAN if available.\n")
    errMsg <- paste(errMsg, "They will be saved under", pkgSrcDir, "\n")
    cat(errMsg)
    # Downloading
    for(pkg in missingSrcsReqPkgs) {
      tryCatch(
        {
          download.packages(pkg, destdir=pkgSrcDir, repos=remoteRepo, type="source")
          downloadedPkgs <- c(downloadedPkgs, pkg)
        },
        warning=function(w) warning(w),
        error=function(e) warning(e)
      )
    }
    if(length(downloadedPkgs)>0) {
      cat("Updating local R repo... ")
      write_PACKAGES(dir=pkgSrcDir)
      availablePkgsLocalRepo <- available.packages(repos=localRepo)
      cat("Done.\n")
    }
  } else {
    errMsg <- paste('WARNING: ', errMsg,'\n', errMsgSolveMissingPkgs)
    cat(errMsg)
  }
  # Updating missing pkgs list
  missingSrcsReqPkgs <- missingSrcsReqPkgs[!(missingSrcsReqPkgs %in% downloadedPkgs)]
  if(length(missingSrcsReqPkgs)>0) {
    ignoredPkgs <- missingSrcsReqPkgs[missingSrcsReqPkgs %in% pkgsSafeToIgnore]
    pkgsCannotBeIgnored <- missingSrcsReqPkgs[!(missingSrcsReqPkgs %in% pkgsSafeToIgnore)]
    # Updating allPkgs and srcsReqInRepo lists to take into account ignored pkgs
    allPkgs <- allPkgs[!(allPkgs %in% ignoredPkgs)]
    srcsReqInRepo <- srcsReqInRepo[!(srcsReqInRepo %in% ignoredPkgs)]
    pkgsToBeInstalled <- pkgsToBeInstalled[!(pkgsToBeInstalled %in% ignoredPkgs)]

    if(length(ignoredPkgs)>0) {
      cat("\n")
      cat('Ignoring the following missing R-libs (see variable "pkgsSafeToIgnore"):\n')
      for (pkg in pkgsSafeToIgnore) {
        cat("    *", pkg, "\n")
      }
    }

    if(length(pkgsCannotBeIgnored)>0) {
      errMsg <- sprintf(
        'The following %d pkg sources are missing and cannot be ignored:\n',
        length(pkgsCannotBeIgnored)
      )
      for(pkg in pkgsCannotBeIgnored) {
        errMsg <- paste(errMsg, "  >", pkg, "\n")
      }
      errMsg <- paste(errMsg, "\n", errMsgSolveMissingPkgs)
      errMsg <- paste(errMsg, "\n", "Cannot countinue.\n")
      cat("\n")
      stop(errMsg)
    }
  }
}

# Build step
# At this point, sources for all required R-libs should be available locally
binSearchPaths <- c(localPreCompiledPkgsDir, envVarPreCompiledPkgsDir)
cat("Looking for pre-compiled binaries at:\n")
for(dir in binSearchPaths) cat(paste("  >", dir, "\n"))
pathsAllBinFilesFound <- listBinFiles(binSearchPaths)
pathsToBinsThatAreReady <- c()
if(rebuildAll | length(pathsAllBinFilesFound)==0) {
  binsToBeBuilt <- allPkgs
} else {
  binsToBeBuilt <- c()
  for (pkgName in srcsReqInRepo) {
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    fPath <- pathToBinary(
               pkgName, pkgVer, platform=sysInfoStringShort,
               fullBinList=pathsAllBinFilesFound
             )
    if(anyNA(fPath)) {
      binsToBeBuilt <- c(binsToBeBuilt, pkgName)
    } else {
      pathsToBinsThatAreReady <- c(pathsToBinsThatAreReady, fPath)
    }
  }
}

libsFailedToBuild <- c()
if(length(binsToBeBuilt)==0) {
  cat("All needed binaries are available. No binaries need to be built.\n")
} else {
  cat("\n")
  cat("The following R-libraries are marked to be built:\n")
  for (pkgName in binsToBeBuilt) {
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    cat("  >", pkgName, paste("(v", pkgVer, ")", sep=''), "\n")
  }
  cat("Total:", length(binsToBeBuilt), "R-libraries to be built.\n")

  cat("\n")
  if(length(pathsToBinsThatAreReady)>0) {
    # If we do not do this, then install.packages may download these pkgs
    cat(sprintf(
      "Copying %d already compiled R-pkg deps to temp build area...",
      length(pathsToBinsThatAreReady)
    ))
    install_binaries(fPaths=pathsToBinsThatAreReady, lib=tmpLibForBuild, overwrite=FALSE)
    cat(" Done.\n")
  }
  cat("Building now...\n")
  # Moving to a tempdir so that the work dir doesn't get full of tarballs
  setwd(tmpDirForBuild)

  iLib <- 0
  for (pkgName in binsToBeBuilt) {
    iLib <- iLib+ 1
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    cat(sprintf(
      paste0(
        '\n############################################################################\n',
        '                    Building (%d/%d): %s-%s\n',
        '############################################################################\n'
      ),
      iLib, length(binsToBeBuilt), pkgName, pkgVer
    ))
    tryCatch({
        install.packages(pkgName, lib=tmpLibForBuild,
          repos=localRepo, type="source", INSTALL_opts="--build",
          dependencies=FALSE,
          configure.args=installPkgsConfigArgs,
          configure.vars=installPkgsConfigVars
        )
      },
        warning = function(w) {
          handleInstallFailure(
            w, pkgName, okToProceed=allSuggestsDeps,ignoreBuildFail=ignoreBuildFail
          )
          libsFailedToBuild <<- c(libsFailedToBuild, pkgName)
        },
        # Copying compiled binaries, so they are available next time
        finally=mvPkgsBinsToRepo(tmpDirForBuild, localPreCompiledPkgsDir)
    )
    cat("\n")
  }
  # Back to the original dir
  setwd(workDir)
  cat("Build finished.\n")
}
if(buildOnly) {
  cat('Flag "--build" passed. Not installing.\n')
  quit()
}

# Install step
# At this stage, all needed binaries should be available
cat("\n")
# Cretaing symlink to localInstallRLib
symlinkTarget <- gsub(paste("^", workDir, "{1}/*", sep=""), "", localInstallRLib)
unlink(basename(localInstallRLib))
symlinkCreated <- file.symlink(symlinkTarget, basename(localInstallRLib))

pkgsToBeInstalled <- pkgsToBeInstalled[!(pkgsToBeInstalled %in% libsFailedToBuild)]
if(length(pkgsToBeInstalled)==0) {
  cat("###############################################################\n")
  cat("Nothing to be installed.\n")
  if(length(libsFailedToBuild)==0) {
    cat("  > The listed R-libraries seem to already be in place.\n")
  } else {
    cat("  > WARN: The following libraries failed to build, please doube-check:\n")
    for (pkg in libsFailedToBuild) {
      cat("  >", pkg, "\n")
    }
  }
  cat("###############################################################\n")
  quit()
} else {
  cat("R libraries will (if needed) be installed to: ", lib, "\n")
  cat("\n")
}

pkgsToBeUpdated <- pkgsToBeUpdated[!(pkgsToBeUpdated %in% libsFailedToBuild)]
if(length(pkgsToBeUpdated)>0) {
  cat("\n")
  cat("The following R-libraries will be updated:\n")
  for (pkg in pkgsToBeUpdated) {
    cat("  >", pkg, "\n")
  }
  cat("Total:", length(pkgsToBeUpdated), "R-libraries to be updated.\n")
}

# Convenience function to help printing install progress
printInstallStatus <- function(newStatus) {
  blankLine <- strrep(" ", getOption("width"))
  cat(paste0("\r", blankLine, "\r", newStatus))
}

pathsAllBinFilesFound <- listBinFiles(binSearchPaths)
iLib <- 0
for (pkgName in pkgsToBeInstalled) {
  pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
  installAction <- "Installing"
  if(pkgName %in% pkgsToBeUpdated) installAction <- "Updating"
  installStatus <- sprintf(
    "Installation (%.0f%%): %s R-lib %s-%s...",
    100*(iLib / length(pkgsToBeInstalled)), installAction, pkgName, pkgVer
  )
  printInstallStatus(installStatus)

  preCompPkgPath <- pathToBinary(
                      pkgName, pkgVer, platform=sysInfoStringShort,
                      fullBinList=pathsAllBinFilesFound
                    )
  install_binaries(fPaths=preCompPkgPath, lib=lib, overwrite=TRUE)
  iLib <- iLib + 1
}

printInstallStatus(sprintf(
  "Installation: %d R-libraries have been installed.\n",
  length(pkgsToBeInstalled)
))
cat("\n")
cat("############################################\n")
cat("# The R-libs installer script has finished #\n")
cat("############################################\n")
