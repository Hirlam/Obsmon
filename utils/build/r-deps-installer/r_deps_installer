#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly=FALSE)

getArgVal <- function(argName) {
  argPatt <- paste(argName, "={1}", sep="")
  argStr <- grep(argPatt, args, value=TRUE)

  if(length(argStr)==0) argVal <- NULL
  else {
    argVal <- gsub(argPatt, "", argStr)
    if(anyNA(argVal) | argVal=="") argVal <- NULL
  }
  return(argVal)
}

printInstallStatus <- function(newStatus) {
  blankLine <- strrep(" ", getOption("width"))
  cat(paste0("\r", blankLine, "\r", newStatus))
}

showDepsAndQuit <- "--listdeps" %in% args
buildOnly <- "--build" %in% args # Just build, do not install
rebuildAll <- "--rebuild-all" %in% args
# Options that control whether downloads can be made from CRAN or not
# You should only use --reset-local-repo if you know what you are doing
resetLocalRepo <- "--reset-local-repo" %in% args
allowSrcDownload <- "--allow-downloads" %in% args | resetLocalRepo
# --pedantic: Requires all srcs and builds all missing binaries.
pedanticBuild <- "--pedantic" %in% args
# --local-install is useful whenever minimum interference with current R setup
# is desirable
localReinstallRequested <- "--local-reinstall" %in% args
localInstallRequested <- "--local-install" %in% args || localReinstallRequested
# The sf R library is only needed as a "requires" dependency and is not
# installed be default, as it depends on gdal v2, which is not available
# in some systems yet.
sfSuggestsSupport <- "--sf-suggests-support" %in% args
# Optional user-specified workDir
workDirUserArg <- getArgVal("--workdir")
# Path to the local R library directory (relative to workDir)
# (to replace the default localRLibDir, optionally)
localRLibDirUserArg <- getArgVal("--local-R-lib-dir")

# List here R-libraries that can be ignored
pkgsSafeToIgnore <- c("RadarBE")
excludeFromSuggests <- c("sf")

# Getting file path and defining workDir
thisFileRelPath <- getArgVal("--file")
thisFileDir <- normalizePath(dirname(thisFileRelPath))
thisFileName <- basename(thisFileRelPath)
thisFileAbsPath <- file.path(thisFileDir, thisFileName)
# Accounting for the fact that the script may be executed via a symlink
thisFileRealPath <- normalizePath(thisFileAbsPath)
thisFileRealDirPath <- normalizePath(dirname(thisFileRealPath))
workDir <- thisFileDir
if(!is.null(workDirUserArg)) workDir <- normalizePath(workDirUserArg)
setwd(workDir)

tmpDirForBuild <- normalizePath(tempdir())
includeDirR <- file.path(thisFileRealDirPath, "include", "R")
source(file.path(includeDirR, "getSysInfo.R"))
source(file.path(includeDirR, "dependencies.R"))
source(file.path(includeDirR, "getExplicitlyUsedRPkgs.R"))
source(file.path(includeDirR, "handleInstallFailure.R"))
source(file.path(includeDirR, "auxFileFunctions.R"))
source(file.path(includeDirR, "binFilesAuxFunctions.R"))

sysInfoStringShort <- getSysInfo()
sysInfoStringLong <- getSysInfo(includeSysName=TRUE, includeSysRelease=TRUE)

localRLibDir <- file.path(workDir,"utils", "build", "local_R_library")
if(!is.null(localRLibDirUserArg)) {
  localRLibDir <- file.path(workDir, localRLibDirUserArg)
}
pkgSrcDir <- file.path(localRLibDir, "src", "contrib")
localInstallRLib <- file.path(localRLibDir, "R-libs")
localPreCompiledPkgsDir <- file.path(localRLibDir, "pre_compiled", sysInfoStringLong)
envVarPreCompiledPkgsDir <- file.path(
  unlist(strsplit(Sys.getenv("R_LIBS_BIN_REPO_ROOTDIR"), ":")),
  sysInfoStringLong
)

# Remove locally installed R-libraries if localReinstallRequested
if(localReinstallRequested) {
  cat(sprintf(
    'Option "--local-reinstall" passed.\n  > Resetting directory %s\n',
    localInstallRLib
  ))
  unlink(localInstallRLib, recursive=TRUE)
}

remoteRepo <- c("http://cran.ma.imperial.ac.uk/")
localRepo <- c(file.path("file:", localRLibDir))
# Configuring library search paths
originalLibPaths <- .libPaths()
.libPaths("")
if(localInstallRequested) {
  lib <- localInstallRLib
} else {
  .libPaths(originalLibPaths)
  userRLib <- Sys.getenv("R_LIBS_USER")
  if(userRLib=="") userRLib <- file.path(Sys.getenv("HOME"), "R", "library")
  lib <- userRLib
}
lib <- path.expand(lib)
tmpLibForBuild <- file.path(tmpDirForBuild, "temp_R_lib")
newLibPaths <- unique(c(localInstallRLib, lib, tmpLibForBuild, .libPaths()))
for (dir in newLibPaths) if(!dir.exists(dir)) dir.create(dir, recursive=TRUE)
.libPaths(newLibPaths)
cat("Directories in the R library search path (in order of priority):\n")
for(dir in .libPaths()) {
  cat(paste("  >", dir, "\n"))
}
cat("\n")

# Initialising local repo if it doesn't exist
if(!dir.exists(pkgSrcDir)) {
  dir.create(pkgSrcDir, recursive=TRUE)
  file.create(file.path(pkgSrcDir, "PACKAGES"))
}
if(!dir.exists(localPreCompiledPkgsDir)) dir.create(localPreCompiledPkgsDir, recursive=TRUE)

availablePkgsLocalRepo <- available.packages(repos=localRepo)

cat('Gathering R-libraries used in the ".R" files in current dir and subdirs...')
# These may have been imported explicitly using "library" or "require",
# or used without explicit import (double-colon syntax).
allFiles <- list.files(path=".", recursive=TRUE, full.names=TRUE)
allFiles <- allFiles[!grepl(basename(localInstallRLib), allFiles)]
# The local R library will certainly contain R files, but we wil handle those
# via the "dependencies" function
allRFiles <- allFiles[filesAreR(allFiles)]
mainPkgs <- getExplicitlyUsedRPkgs(allRFiles)

cat("Done.\n  > The following",length(mainPkgs),"main R-libraries were found:\n")
for (pkg in mainPkgs) {
  cat("    *", pkg, "\n")
}

cat("\n")
cat("Getting recursive dependency list: \n")
# Doing this manually because we've had too many problems with somewhat erratic
# behaviour of the install.packages own dependency resolution
pkgsDeps <- list()
# Having separate lists with the names of essential R-libs and libs that
# are only needed as "Suggests"-type dependencies (and recursive dependencies
# of these) will allow us, later on, to decide what to do in case a package
# fails to be installed
allEssentialDeps <- c()
allSuggestsDeps <- c()
allPkgDeps <- c()
essentialDepsTypes <- c("Depends", "Imports", "LinkingTo")
# Warning user if sf is to be installed as a suggests-type dependency, as this
# may cause installation to fail in some systems due to the lack of gdal v2
if(sfSuggestsSupport) {
  cat("WARNING: Support to the sf R library requires gdal>2.0.\n")
  cat("         The build will fail if your system doesn't have gdal v2.\n")
  excludeFromSuggests <- excludeFromSuggests[!(excludeFromSuggests %in% "sf")]
}

mainPkgsNotAvailableLocally <- mainPkgs[!(mainPkgs %in% rownames(availablePkgsLocalRepo))]
if(resetLocalRepo | length(mainPkgsNotAvailableLocally)>0) {
  availablePkgsRemoteRepo <- available.packages(repos=remoteRepo)
}
pkgsDbForDepsRefresh <- availablePkgsLocalRepo
if(resetLocalRepo) pkgsDbForDepsRefresh <- availablePkgsRemoteRepo

for (pkg in mainPkgs) {
  cat("  >", pkg, "... ")

  if(resetLocalRepo | (pkg %in% mainPkgsNotAvailableLocally)) {
    pkgsDbForDepsRefresh <- availablePkgsRemoteRepo
  } else {
    pkgsDbForDepsRefresh <- availablePkgsLocalRepo
  }
  essentialDeps <- dependencies(pkg, db=pkgsDbForDepsRefresh,
                     levelOneDepsType=essentialDepsTypes,
                     exclude_from_suggests=excludeFromSuggests
                   )
  suggestsDeps <- dependencies(pkg, db=pkgsDbForDepsRefresh,
                    levelOneDepsType="Suggests",
                    exclude_from_suggests=excludeFromSuggests
                  )
  # A Suggests type dependency may also end up being a recursive non-suggests
  # dependency of the essential R-libraries. We don't want to have these
  # considered as optional.
  suggestsDeps <- suggestsDeps[!(suggestsDeps %in% essentialDeps)]
  pkgsDeps[[pkg]] <- list(essential=essentialDeps, Suggests=suggestsDeps)

  thisPkgDeps <-c(pkgsDeps[[pkg]][["essential"]],pkgsDeps[[pkg]][["Suggests"]])
  newDeps <-setdiff(thisPkgDeps,intersect(thisPkgDeps,c(mainPkgs, allPkgDeps)))
  cat("nDependencies =", length(thisPkgDeps), "(", length(newDeps),"new)\n")
  allEssentialDeps <- c(allEssentialDeps, pkgsDeps[[pkg]][["essential"]])
  allSuggestsDeps <- c(allSuggestsDeps, pkgsDeps[[pkg]][["Suggests"]])
  allPkgDeps <- c(allPkgDeps, allEssentialDeps, allSuggestsDeps)
}

# At last, building the full list of pkgs to be installed
allPkgs <- unique(c(allPkgDeps, mainPkgs))
allEssentialDeps <- unique(allEssentialDeps[!(allEssentialDeps %in% mainPkgs)])
allSuggestsDeps <- unique(
                     allSuggestsDeps[
                       !(allSuggestsDeps %in% c(allEssentialDeps, mainPkgs))
                     ]
                   )

cat("\n")
msg <- "In addition to the main R-libraries listed above,"
msg <- paste(msg, "the following dependencies should also", sep=" ")
msg <- paste(msg, "be available after a successful full install:\n", sep="\n")
cat(msg)
cat("* Essential dependencies:\n")
for (pkg in sort(allEssentialDeps)) {
  cat("  >", pkg, "\n")
}
cat("* Suggests-type dependencies:\n")
for (pkg in sort(allSuggestsDeps)) {
  cat("  >", pkg, "\n")
}
cat("Total:", length(allPkgs), "R-libraries.\n")
cat("  Main R-libraries:", length(mainPkgs), "\n")
cat("  Essential dependencies:", length(allEssentialDeps), "\n")
cat("  Suggests-type dependencies:", length(allSuggestsDeps), "\n")
cat("\n")

if(showDepsAndQuit) {
  cat('Option "--listdeps" passed. Not installing R-libraries. \n')
  cat('Stopping now.\n')
  quit()
}

# Checking what needs to be done
installedPkgs <- installed.packages(lib.loc=lib)[,1]
pkgsToBeUpdated <- rownames(old.packages(lib.loc=lib, repos=localRepo))
pkgsToBeInstalledMask <- !(allPkgs %in% installedPkgs)
pkgsToBeInstalledMask <- pkgsToBeInstalledMask | (allPkgs %in% pkgsToBeUpdated)
pkgsToBeInstalled <- allPkgs[pkgsToBeInstalledMask]
# If the "--pedantic" command line option is passed, then the script will
# require that the repo contains all source files for the R-libs used in
# the code, even if they are already installed in the system.
# This is to ensure that distributing the code as part of a package (such
# as an RPM, for instance) is done in a consistent fashion.
#
# If that command line option is not passed, then the script will only require
# the existence of sources for R-libraries that are not yet installed.
srcsReqInRepo <- pkgsToBeInstalled
if(pedanticBuild | rebuildAll) srcsReqInRepo <- allPkgs

if(resetLocalRepo) {
  cat('WARNING: Flag "--reset-local-repo" passed. The local R source repo will be reset using CRAN!')
  unlink(pkgSrcDir, recursive=TRUE)
  dir.create(pkgSrcDir, recursive=TRUE)
  missingSrcsReqPkgs <- srcsReqInRepo
} else {
  missingSrcsReqPkgs <- srcsReqInRepo[!(srcsReqInRepo %in% rownames(availablePkgsLocalRepo))]
}


errMsgSolveMissingPkgs <- paste(
  '>>> If you wish the missing sources to be downloaded automatically, please\n',
  '    run the installation script with the option "--allow-downloads',
  '\n \n',
  "You can also manually add the missing package tarballs to the\n",
  pkgSrcDir, "\n",
  "directory, go to that directory, open R, run\n",
  "    tools::write_PACKAGES() \n",
  '    db = read.dcf("PACKAGES") \n',
  '    saveRDS(db, "PACKAGES.rds") \n',
  "to update the repo, and try again.\n"
)

if(length(missingSrcsReqPkgs)>0) {
  # Deciding whether or not to download needed source files that are missing.
  errMsg <- "The local R repo does not contain all required sources!\n"
  errMsg <- paste(errMsg,
              "Sources are missing for the following R-libraries:\n",
               sep=""
            )
  for(pkgName in missingSrcsReqPkgs) {
    errMsg <- paste(errMsg, "  >", pkgName, "\n")
  }

  downloadedPkgs <- c()
  if(allowSrcDownload) {
    errMsg <- paste(errMsg, "Missing sources will be downloaded from CRAN if available.\n")
    errMsg <- paste(errMsg, "They will be saved under", pkgSrcDir, "\n")
    cat(errMsg)
    # Downloading
    for(pkg in missingSrcsReqPkgs) {
      tryCatch(
        {
          download.packages(pkg, destdir=pkgSrcDir, repos=remoteRepo, type="source")
          downloadedPkgs <- c(downloadedPkgs, pkg)
        },
        warning=function(w) warning(w),
        error=function(e) warning(e)
      )
    }
    if(length(downloadedPkgs)>0) {
      cat("Updating local R repo... ")
      write_PACKAGES(dir=pkgSrcDir)
      availablePkgsLocalRepo <- available.packages(repos=localRepo)
      cat("Done.\n")
    }
  } else {
    errMsg <- paste('WARNING: ', errMsg,'\n', errMsgSolveMissingPkgs)
    cat(errMsg)
  }
  # Updating missing pkgs list
  missingSrcsReqPkgs <- missingSrcsReqPkgs[!(missingSrcsReqPkgs %in% downloadedPkgs)]
  if(length(missingSrcsReqPkgs)>0) {
    ignoredPkgs <- missingSrcsReqPkgs[missingSrcsReqPkgs %in% pkgsSafeToIgnore]
    pkgsCannotBeIgnored <- missingSrcsReqPkgs[!(missingSrcsReqPkgs %in% pkgsSafeToIgnore)]
    # Updating allPkgs and srcsReqInRepo lists to take into account ignored pkgs
    allPkgs <- allPkgs[!(allPkgs %in% ignoredPkgs)]
    srcsReqInRepo <- srcsReqInRepo[!(srcsReqInRepo %in% ignoredPkgs)]
    pkgsToBeInstalled <- pkgsToBeInstalled[!(pkgsToBeInstalled %in% ignoredPkgs)]

    if(length(ignoredPkgs)>0) {
      cat("\n")
      cat('Ignoring the following missing R-libs (see variable "pkgsSafeToIgnore"):\n')
      for (pkg in pkgsSafeToIgnore) {
        cat("    *", pkg, "\n")
      }
    }

    if(length(pkgsCannotBeIgnored)>0) {
      errMsg <- 'The following pkg sources are missing and cannot be ignored:\n'
      for(pkg in pkgsCannotBeIgnored) {
        errMsg <- paste(errMsg, "  >", pkg, "\n")
      }
      errMsg <- paste(errMsg, "\n", errMsgSolveMissingPkgs)
      errMsg <- paste(errMsg, "\n", "Cannot countinue.\n")
      cat("\n")
      stop(errMsg)
    }
  }
}

# Build step
# At this point, sources for all required R-libs should be available locally
binSearchPaths <- c(localPreCompiledPkgsDir, envVarPreCompiledPkgsDir)
cat("Looking for pre-compiled binaries at:\n")
for(dir in binSearchPaths) cat(paste("  >", dir, "\n"))
binFilePaths <- listBinFiles(binSearchPaths)
if(rebuildAll | length(binFilePaths)==0) {
  binsToBeBuilt <- allPkgs
} else {
  binsToBeBuilt <- c()
  for (pkgName in srcsReqInRepo) {
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    fPath <- pathToBinary(
               pkgName, pkgVer, platform=sysInfoStringShort,
               fullBinList=binFilePaths
             )
    if(anyNA(fPath)) binsToBeBuilt <- c(binsToBeBuilt, pkgName)
  }
}

if(length(binsToBeBuilt)==0) {
  cat("All needed binaries are available. No binaries need to be built.\n")
} else {
  cat("\n")
  cat("The following R-libraries are marked to be built:\n")
  for (pkgName in binsToBeBuilt) {
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    cat("  >", pkgName, paste("(v", pkgVer, ")", sep=''), "\n")
  }
  cat("Total:", length(binsToBeBuilt), "R-libraries to be built.\n")

  cat("\n")
  # If we do not do this, then install.packages may download these pkgs
  cat("Handling eventual pre-compiled but not installed R-pkg dependencies...")
  install_binaries(fPaths=binFilePaths, lib=tmpLibForBuild, overwrite=FALSE)
  cat(" Done.\n")
  cat("Building now...\n")
  # Moving to a tempdir so that the work dir doesn't get full of tarballs
  setwd(tmpDirForBuild)

  iLib <- 0
  for (pkgName in binsToBeBuilt) {
    iLib <- iLib+ 1
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    cat(sprintf(
      paste0(
        '\n############################################################################\n',
        '                    Building (%d/%d): %s-%s\n',
        '############################################################################\n'
      iLib, length(binsToBeBuilt), pkgName, pkgVer
    ))
    tryCatch(
      install.packages(pkgName, lib=tmpLibForBuild,
        repos=localRepo, type="source", INSTALL_opts="--build",
        configure.args=c(udunits2='--with-udunits2-include=/usr/include/udunits2')
      ),
      warning = function(w) handleInstallFailure(w, okToProceed=allSuggestsDeps),
      # Copying compiled binaries, so they are available next time
      finally=mvPkgsBinsToRepo(tmpDirForBuild, localPreCompiledPkgsDir)
    )
    cat("\n")
  }
  # Back to the original dir
  setwd(workDir)
  cat("Build finished.\n")
}
if(buildOnly) {
  cat('Flag "--build" passed. Not installing.\n')
  quit()
}

# Install step
# At this stage, all needed binaries should be available
cat("\n")
# Cretaing symlink to localInstallRLib
symlinkTarget <- gsub(paste("^", workDir, "{1}/*", sep=""), "", localInstallRLib)
unlink(basename(localInstallRLib))
symlinkCreated <- file.symlink(symlinkTarget, basename(localInstallRLib))

cat("R libraries will (if needed) be installed to: ", lib, "\n")
cat("\n")
if(length(pkgsToBeInstalled)==0) {
 cat("The listed packages seem to have already been installed.\n")
 cat("Nothing to do.\n")
 quit()
}

if(length(pkgsToBeUpdated)>0) {
  cat("\n")
  cat("The following R-libraries will be updated:\n")
  for (pkg in pkgsToBeUpdated) {
    cat("  >", pkg, "\n")
  }
  cat("Total:", length(pkgsToBeUpdated), "R-libraries to be updated.\n")
}

binFilePaths <- listBinFiles(binSearchPaths)
iLib <- 0
for (pkgName in pkgsToBeInstalled) {
  pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
  installAction <- "Installing"
  if(pkgName %in% pkgsToBeUpdated) installAction <- "Updating"
  installStatus <- sprintf(
    "Installation (%.0f%%): %s R-lib %s-%s...",
    100*(iLib / length(pkgsToBeInstalled)), installAction, pkgName, pkgVer
  )
  printInstallStatus(installStatus)

  preCompPkgPath <- pathToBinary(
                      pkgName, pkgVer, platform=sysInfoStringShort,
                      fullBinList=binFilePaths
                    )
  install_binaries(fPaths=preCompPkgPath, lib=lib, overwrite=TRUE)
  iLib <- iLib + 1
}

printInstallStatus(sprintf(
  "Installation: %d R-libraries have been installed.\n",
  length(pkgsToBeInstalled)
))
cat("\n")
cat("############################################\n")
cat("# The R-libs installer script has finished #\n")
cat("############################################\n")
