#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly=TRUE)
showDepsAndQuit <- "--listdeps" %in% args
refreshDeps <- "--refreshdeps" %in% args
allowSrcDownload <- !"--abort-if-src-missing" %in% args
buildOnly <- "--build" %in% args # Just build, do not install
rebuildAll <- "--rebuild-all" %in% args
# --pedantic: Requires all srcs and builds all missing binaries.
pedanticBuild <- "--pedantic" %in% args 
# --local-install is useful whenever minimum interference with current R setup
# is desirable
localInstallRequested <- "--local-install" %in% args 

workDir <- normalizePath(getwd())
tmpDirForBuild <- normalizePath(tempdir())
includeDirR <- file.path(workDir, "utils", "build", "include", "R")
source(file.path(includeDirR, "getSysInfo.R"))
source(file.path(includeDirR, "dependencies.R"))
source(file.path(includeDirR, "getExplicitlyUsedRPkgs.R"))
source(file.path(includeDirR, "handleInstallFailure.R"))
source(file.path(includeDirR, "binFilesAuxFunctions.R"))

sysInfoString <- getSysInfo()
localRLibDir <- file.path(workDir,"utils", "build", "local_R_library")
depsCacheFile <- file.path(workDir,"utils", "build", "pkg_dependencies.Rdata")
pkgSrcDir <- file.path(localRLibDir, "src", "contrib")
preCompiledPkgsDir <- file.path(localRLibDir, "pre_compiled", sysInfoString)
localInstallRLib <- file.path(localRLibDir, "locally_installed_R_library")

remoteRepo <- c("http://cran.ma.imperial.ac.uk/")
localRepo <- c(file.path("file:", localRLibDir))
availablePkgsLocalRepo <- available.packages(repos=localRepo)
binFileNames <- list.files(
                  preCompiledPkgsDir, pattern="\\.tar\\.gz$|\\.tgz$",
                  full.names=TRUE
                )

# Configuring library search paths
userRLib <- Sys.getenv("R_LIBS_USER")
if(userRLib=="") userRLib <- file.path(Sys.getenv("HOME"), "R", "library")
lib <- userRLib
if(localInstallRequested) lib <- localInstallRLib
lib <- path.expand(lib)
tmpLibForBuild <- file.path(tmpDirForBuild, "temp_R_lib")
.libPaths(unique(c(localInstallRLib, userRLib, lib, tmpLibForBuild, .libPaths())))
cat("Directories in the R library search path (in order of priority):\n")
for(dir in .libPaths()) {
  cat(paste("  >", dir, "\n"))
}
cat("\n")

for (dir in c(lib, tmpLibForBuild, pkgSrcDir, preCompiledPkgsDir)) {
  if(!dir.exists(dir)) dir.create(dir, recursive=TRUE)
}

cat('Gathering packages used in the ".R" files in current dir and subdirs...')
# These may have been imported explicitly using "library" or "require",
# or used without explicit import (double-colon syntax).
allRFiles <- list.files(pattern="\\.R$", recursive=TRUE)
mainPkgs <- getExplicitlyUsedRPkgs(allRFiles)

cat("Done.\n  > The following",length(mainPkgs),"main packages were found:\n")
for (pkg in mainPkgs) {
  cat("    *", pkg, "\n")
}

cat("\n")
cat("Getting recursive dependency list: \n")
# Doing this manually because we've had too many problems with somewhat erratic
# behaviour of the install.packages own dependency resolution
# First, attempt to read cached dependencies to avoid checking online
pkgsDeps <- list()
if(file.exists(depsCacheFile)) {
  pkgsDeps <- readRDS(depsCacheFile)
}
depsRefreshed <- FALSE
# Having separate lists with the names of essencial packages and packages that
# are only needed as "Suggests"-type dependencies (and recursive dependencies
# of these) will allow us, later on, to decide what to do in case a package
# fails to be installed
allEssencialDeps <- c()
allSuggestsDeps <- c()
allPkgDeps <- c()
essentialDepsTypes <- c("Depends", "Imports", "LinkingTo")
for (pkg in mainPkgs) {
  cat("  >", pkg, "... ")
  if(refreshDeps | !(pkg %in% names(pkgsDeps))) {
    availablePkgsRemote <- available.packages(repos=remoteRepo)
    essencialDeps <- dependencies(pkg, db=availablePkgsRemote,
                       levelOneDepsType=essentialDepsTypes
                     )
    suggestsDeps <- dependencies(pkg, db=availablePkgsRemote,
                      levelOneDepsType="Suggests"
                    )
    # A Suggests type dependency may also end up being a recursive non-suggests
    # dependency of the essencial packages. We don't want to have these
    # considered as optional.
    suggestsDeps <- suggestsDeps[!(suggestsDeps %in% essencialDeps)]
    pkgsDeps[[pkg]] <- list(essencial=essencialDeps, Suggests=suggestsDeps)
    depsRefreshed <- TRUE
  }
  thisPkgDeps <-c(pkgsDeps[[pkg]][["essencial"]],pkgsDeps[[pkg]][["Suggests"]])
  newDeps <-setdiff(thisPkgDeps,intersect(thisPkgDeps,c(mainPkgs, allPkgDeps)))
  cat("nDependencies =", length(thisPkgDeps), "(", length(newDeps),"new)\n")
  allEssencialDeps <- c(allEssencialDeps, pkgsDeps[[pkg]][["essencial"]])
  allSuggestsDeps <- c(allSuggestsDeps, pkgsDeps[[pkg]][["Suggests"]])
  allPkgDeps <- c(allPkgDeps, allEssencialDeps, allSuggestsDeps)
}
if(depsRefreshed) saveRDS(pkgsDeps, file=depsCacheFile)

# At last, building the full list of pkgs to be installed
allPkgs <- unique(c(allPkgDeps, mainPkgs))
allEssencialDeps <- unique(allEssencialDeps[!(allEssencialDeps %in% mainPkgs)])
allSuggestsDeps <- unique(
                     allSuggestsDeps[
                       !(allSuggestsDeps %in% c(allEssencialDeps, mainPkgs))
                     ]
                   )

cat("\n")
msg <- "In addition to the main packages listed above,"
msg <- paste(msg, "the following dependencies should also", sep=" ")
msg <- paste(msg, "be available after a successful full install:\n", sep="\n")
cat(msg)
cat("* Essencial dependencies:\n")
for (pkg in sort(allEssencialDeps)) {
  cat("  >", pkg, "\n")
}
cat("* Suggests-type dependencies:\n")
for (pkg in sort(allSuggestsDeps)) {
  cat("  >", pkg, "\n")
}
cat("Total:", length(allPkgs), "packages.\n")
cat("  Main packages:", length(mainPkgs), "\n")
cat("  Essencial dependencies:", length(allEssencialDeps), "\n")
cat("  Suggests-type dependencies:", length(allSuggestsDeps), "\n")
cat("\n")

if(showDepsAndQuit) {
  cat('Option "--listdeps" passed. Not installing packages. \n')
  cat('Stopping now.\n')
  quit()
}

# Checking what needs to be done
installedPkgs <- installed.packages(lib.loc=lib)[,1]
pkgsToBeUpdated <- rownames(old.packages(lib.loc=lib, repos=localRepo))
pkgsToBeInstalledMask <- !(allPkgs %in% installedPkgs)
pkgsToBeInstalledMask <- pkgsToBeInstalledMask | (allPkgs %in% pkgsToBeUpdated)
pkgsToBeInstalled <- allPkgs[pkgsToBeInstalledMask]
# If the "--pedantic" command line option is passed, then the script will
# require that the repo contains all source files for the packages used in 
# the code, even if they are already installed in the system.
# This is to ensure that distributing the code as part of a package (such
# as an RPM, for instance) is done in a consistent fashion.
#
# If that command line option is not passed, then the script will only require
# the existence of sources for packages that are not yet installed.
srcsReqInRepo <- pkgsToBeInstalled
if(pedanticBuild | rebuildAll) srcsReqInRepo <- allPkgs

missingSrcsReqPkgs <- srcsReqInRepo[!(srcsReqInRepo %in% rownames(availablePkgsLocalRepo))]
if(length(missingSrcsReqPkgs)>0) {
  # Deciding whether or not to download needed source files that are missing.
  # The default is to download them. This is to keep backwards compatibility.
  # It is preferrable, however, to have them downloaded and verified in a
  # secure computer, and then moved to pkgSrcDir once they are considered safe.
  # Use the "--abort-if-missing-src" command line option if you want the
  # install script to abort if sources are not available locally.
  errMsg <- "The local R repo does not contain all required sources!\n"
  errMsg <- paste(errMsg, 
              "Sources are missing for the following packages:\n",
               sep=""
            )
  for(pkgName in missingSrcsReqPkgs) {
    errMsg <- paste(errMsg, "  >", pkgName, "\n")
  }
  if(allowSrcDownload) {
    errMsg <- paste(errMsg, "Missing sources will be downloaded from CRAN.\n")
    errMsg <- paste(errMsg, "They will be saved under", pkgSrcDir, "\n")
    cat(errMsg)
    # Downloading
    download.packages(missingSrcsReqPkgs, destdir=pkgSrcDir,
                      repos=remoteRepo, type="source")
    cat("Updating local R repo... ")
    tools::write_PACKAGES(dir=pkgSrcDir)
    availablePkgsLocalRepo <- available.packages(repos=localRepo)
    cat("Done.\n")
  } else {
    errMsg <- paste(errMsg,'Cannot continue ("--abort-if-src-missing" used)\n')
    errMsg <- paste(errMsg, "Please add the missing package tarballs to the\n")
    errMsg <- paste(errMsg, pkgSrcDir, "\n")
    errMsg <- paste(errMsg, "directory, use R's tools::write_PACKAGES",
                "function to update the repo, and try again.\n"
              )
    stop(errMsg)
  }
}

# Build step
# At this point, sources for all required packages should be available locally
if(rebuildAll | length(binFileNames)==0) {
  binsToBeBuilt <- allPkgs
} else {
  binsToBeBuilt <- c()
  for (pkgName in srcsReqInRepo) {
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    fPath <- pathToBinary(
               pkgName, pkgVer, platform=sysInfoString, 
               fullBinList=binFileNames
             )
    if(is.na(fPath)) binsToBeBuilt <- c(binsToBeBuilt, pkgName)
  }
}

if(length(binsToBeBuilt)==0) {
  cat("All needed binaries are available. No binaries need to be built.\n")
} else {
  cat("\n")
  cat("The following packages are marked to be built:\n")
  for (pkgName in binsToBeBuilt) {
    cat("  >", pkgName, "\n")
  }
  cat("Total:", length(binsToBeBuilt), "packages to be built.\n")

  cat("\n")
  # If we do not do this, then install.packages may download these pkgs
  cat("Handling eventual pre-compiled but not installed R-pkg dependencies...")
  install_binaries(fPaths=binFileNames, lib=tmpLibForBuild, overwrite=FALSE)
  cat(" Done.\n")
  cat("Building now...\n")
  # Moving to a tempdir so that the work dir doesn't get full of tarballs
  setwd(tmpDirForBuild)
  for (pkgName in binsToBeBuilt) {
    tryCatch(
      install.packages(pkgName, lib=tmpLibForBuild,
        repos=localRepo, type="source", INSTALL_opts="--build"
      ),
      warning = function(w) handleInstallFailure(w, okToProceed=allSuggestsDeps),
      # Copying compiled binaries, so they are available next time
      finally=mvPkgsBinsToRepo(tmpDirForBuild, preCompiledPkgsDir)
    )
  }
  # Back to the original dir
  setwd(workDir)
  cat("Build finished.\n")
}
if(buildOnly) {
  cat('Flag "--build" passed. Not installing.\n')
  quit()
}

# Install step
# At this stage, all needed binaries should be available
cat("\n")
cat("R libraries will (if needed) be installed to: ", lib, "\n")
cat("\n")
if(length(pkgsToBeInstalled)==0) {
 cat("The listed packages seem to have already been installed.\n")
 cat("Nothing to do.\n")
 quit()
}

if(length(pkgsToBeUpdated)>0) {
  cat("\n")
  cat("The following packages will be updated:\n")
  for (pkg in pkgsToBeUpdated) {
    cat("  >", pkg, "\n")
  }
  cat("Total:", length(pkgsToBeUpdated), "packages to be updated.\n")
}

binFileNames <- list.files(
                  preCompiledPkgsDir, pattern="\\.tar\\.gz$|\\.tgz$", 
                  full.names=TRUE
                )

for (pkgName in pkgsToBeInstalled) {
  installAction <- "  > Installing"
  if(pkgName %in% pkgsToBeUpdated) installAction <- "  > Updating"
  cat(paste(installAction, " ", pkgName, '... ', sep=""))
  pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
  preCompPkgPath <- pathToBinary(
                      pkgName, pkgVer, platform=sysInfoString, 
                      fullBinList=binFileNames
                    )
  install_binaries(fPaths=preCompPkgPath, lib=lib, overwrite=TRUE)
  cat("Done.\n")
}

cat("\n")
cat("Obsmon install script has finished. \n")
