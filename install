#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly=TRUE)
showDepsAndQuit <- "--listdeps" %in% args
buildOnly <- "--build" %in% args # Just build, do not install
rebuildAll <- "--rebuild-all" %in% args
# Options that control whether downloads can be made from CRAN or not
# You should only use --reset-local-repo if you know what you are doing
resetLocalRepo <- "--reset-local-repo" %in% args
allowSrcDownload <- "--allow-downloads" %in% args | resetLocalRepo
# --pedantic: Requires all srcs and builds all missing binaries.
pedanticBuild <- "--pedantic" %in% args 
# --local-install is useful whenever minimum interference with current R setup
# is desirable
localInstallRequested <- "--local-install" %in% args 
# The sf R library is only needed as a "requires" dependency and is not
# installed be default, as it depends on gdal v2, which is not available
# in some systems yet.
sfSupport <- "--sf-support" %in% args 

workDir <- normalizePath(getwd())
tmpDirForBuild <- normalizePath(tempdir())
includeDirR <- file.path(workDir, "utils", "build", "include", "R")
source(file.path(includeDirR, "getSysInfo.R"))
source(file.path(includeDirR, "dependencies.R"))
source(file.path(includeDirR, "getExplicitlyUsedRPkgs.R"))
source(file.path(includeDirR, "handleInstallFailure.R"))
source(file.path(includeDirR, "binFilesAuxFunctions.R"))

sysInfoStringShort <- getSysInfo()
sysInfoStringLong <- getSysInfo(includeSysName=TRUE, includeSysRelease=TRUE)

localRLibDir <- file.path(workDir,"utils", "build", "local_R_library")
pkgSrcDir <- file.path(localRLibDir, "src", "contrib")
localInstallRLib <- file.path(localRLibDir, "locally_installed_R_library")
localPreCompiledPkgsDir <- file.path(localRLibDir, "pre_compiled", sysInfoStringLong)
envVarPreCompiledPkgsDir <- file.path(
  unlist(strsplit(Sys.getenv("R_LIBS_BIN_REPO_ROOTDIR"), ":")),
  sysInfoStringLong
)

remoteRepo <- c("http://cran.ma.imperial.ac.uk/")
localRepo <- c(file.path("file:", localRLibDir))
availablePkgsLocalRepo <- available.packages(repos=localRepo)

# Configuring library search paths
userRLib <- Sys.getenv("R_LIBS_USER")
if(userRLib=="") userRLib <- file.path(Sys.getenv("HOME"), "R", "library")
lib <- userRLib
if(localInstallRequested) lib <- localInstallRLib
lib <- path.expand(lib)
tmpLibForBuild <- file.path(tmpDirForBuild, "temp_R_lib")
.libPaths(unique(c(localInstallRLib, userRLib, lib, tmpLibForBuild, .libPaths())))
cat("Directories in the R library search path (in order of priority):\n")
for(dir in .libPaths()) {
  cat(paste("  >", dir, "\n"))
}
cat("\n")

for (dir in c(lib, tmpLibForBuild, pkgSrcDir, localPreCompiledPkgsDir)) {
  if(!dir.exists(dir)) dir.create(dir, recursive=TRUE)
}

cat('Gathering packages used in the ".R" files in current dir and subdirs...')
# These may have been imported explicitly using "library" or "require",
# or used without explicit import (double-colon syntax).
allRFiles <- list.files(pattern="\\.R$", recursive=TRUE)
# The local R library will certainly contain R files, but we wil handle those
# via the "dependencies" function
allRFiles <- allRFiles[!grepl(basename(localRLibDir), allRFiles)]
mainPkgs <- getExplicitlyUsedRPkgs(allRFiles)

cat("Done.\n  > The following",length(mainPkgs),"main packages were found:\n")
for (pkg in mainPkgs) {
  cat("    *", pkg, "\n")
}

cat("\n")
cat("Getting recursive dependency list: \n")
# Doing this manually because we've had too many problems with somewhat erratic
# behaviour of the install.packages own dependency resolution
pkgsDeps <- list()
# Having separate lists with the names of essencial packages and packages that
# are only needed as "Suggests"-type dependencies (and recursive dependencies
# of these) will allow us, later on, to decide what to do in case a package
# fails to be installed
allEssencialDeps <- c()
allSuggestsDeps <- c()
allPkgDeps <- c()
essentialDepsTypes <- c("Depends", "Imports", "LinkingTo")
# Warning user if sf is to be intalled, as this may cause installation to fail
# in some systems due to the lack of gdal v due to the lack of gdal v2
exclude_from_suggests <- c("sf")
if(sfSupport) {
  cat("WARNING: Support to the sf R library requires gdal>2.0.\n")
  cat("         The build will fail if your system doesn't have gdal v2.\n")
  exclude_from_suggests <- exclude_from_suggests[!(exclude_from_suggests %in% "sf")]
}

mainPkgsNotAvailableLocally <- mainPkgs[!(mainPkgs %in% rownames(availablePkgsLocalRepo))]
if(resetLocalRepo | length(mainPkgsNotAvailableLocally)>0) {
  availablePkgsRemoteRepo <- available.packages(repos=remoteRepo)
}
pkgsDbForDepsRefresh <- availablePkgsLocalRepo
if(resetLocalRepo) pkgsDbForDepsRefresh <- availablePkgsRemoteRepo 

for (pkg in mainPkgs) {
  cat("  >", pkg, "... ")

  if(resetLocalRepo | (pkg %in% mainPkgsNotAvailableLocally)) {
    pkgsDbForDepsRefresh <- availablePkgsRemoteRepo
  } else {
    pkgsDbForDepsRefresh <- availablePkgsLocalRepo
  }
  essencialDeps <- dependencies(pkg, db=pkgsDbForDepsRefresh,
                     levelOneDepsType=essentialDepsTypes,
                     exclude_from_suggests=exclude_from_suggests
                   )
  suggestsDeps <- dependencies(pkg, db=pkgsDbForDepsRefresh,
                    levelOneDepsType="Suggests",
                    exclude_from_suggests=exclude_from_suggests
                  )
  # A Suggests type dependency may also end up being a recursive non-suggests
  # dependency of the essencial packages. We don't want to have these
  # considered as optional.
  suggestsDeps <- suggestsDeps[!(suggestsDeps %in% essencialDeps)]
  pkgsDeps[[pkg]] <- list(essencial=essencialDeps, Suggests=suggestsDeps)

  thisPkgDeps <-c(pkgsDeps[[pkg]][["essencial"]],pkgsDeps[[pkg]][["Suggests"]])
  newDeps <-setdiff(thisPkgDeps,intersect(thisPkgDeps,c(mainPkgs, allPkgDeps)))
  cat("nDependencies =", length(thisPkgDeps), "(", length(newDeps),"new)\n")
  allEssencialDeps <- c(allEssencialDeps, pkgsDeps[[pkg]][["essencial"]])
  allSuggestsDeps <- c(allSuggestsDeps, pkgsDeps[[pkg]][["Suggests"]])
  allPkgDeps <- c(allPkgDeps, allEssencialDeps, allSuggestsDeps)
}

# At last, building the full list of pkgs to be installed
allPkgs <- unique(c(allPkgDeps, mainPkgs))
allEssencialDeps <- unique(allEssencialDeps[!(allEssencialDeps %in% mainPkgs)])
allSuggestsDeps <- unique(
                     allSuggestsDeps[
                       !(allSuggestsDeps %in% c(allEssencialDeps, mainPkgs))
                     ]
                   )

cat("\n")
msg <- "In addition to the main packages listed above,"
msg <- paste(msg, "the following dependencies should also", sep=" ")
msg <- paste(msg, "be available after a successful full install:\n", sep="\n")
cat(msg)
cat("* Essencial dependencies:\n")
for (pkg in sort(allEssencialDeps)) {
  cat("  >", pkg, "\n")
}
cat("* Suggests-type dependencies:\n")
for (pkg in sort(allSuggestsDeps)) {
  cat("  >", pkg, "\n")
}
cat("Total:", length(allPkgs), "packages.\n")
cat("  Main packages:", length(mainPkgs), "\n")
cat("  Essencial dependencies:", length(allEssencialDeps), "\n")
cat("  Suggests-type dependencies:", length(allSuggestsDeps), "\n")
cat("\n")

if(showDepsAndQuit) {
  cat('Option "--listdeps" passed. Not installing packages. \n')
  cat('Stopping now.\n')
  quit()
}

# Checking what needs to be done
installedPkgs <- installed.packages(lib.loc=lib)[,1]
pkgsToBeUpdated <- rownames(old.packages(lib.loc=lib, repos=localRepo))
pkgsToBeInstalledMask <- !(allPkgs %in% installedPkgs)
pkgsToBeInstalledMask <- pkgsToBeInstalledMask | (allPkgs %in% pkgsToBeUpdated)
pkgsToBeInstalled <- allPkgs[pkgsToBeInstalledMask]
# If the "--pedantic" command line option is passed, then the script will
# require that the repo contains all source files for the packages used in 
# the code, even if they are already installed in the system.
# This is to ensure that distributing the code as part of a package (such
# as an RPM, for instance) is done in a consistent fashion.
#
# If that command line option is not passed, then the script will only require
# the existence of sources for packages that are not yet installed.
srcsReqInRepo <- pkgsToBeInstalled
if(pedanticBuild | rebuildAll) srcsReqInRepo <- allPkgs

if(resetLocalRepo) {
  cat('WARNING: Flag "--reset-local-repo" passed. The local R source repo will be reset using CRAN!')
  unlink(pkgSrcDir, recursive=TRUE)
  dir.create(pkgSrcDir, recursive=TRUE)
  missingSrcsReqPkgs <- srcsReqInRepo
} else {
  missingSrcsReqPkgs <- srcsReqInRepo[!(srcsReqInRepo %in% rownames(availablePkgsLocalRepo))]
}
if(length(missingSrcsReqPkgs)>0) {
  # Deciding whether or not to download needed source files that are missing.
  errMsg <- "The local R repo does not contain all required sources!\n"
  errMsg <- paste(errMsg, 
              "Sources are missing for the following packages:\n",
               sep=""
            )
  for(pkgName in missingSrcsReqPkgs) {
    errMsg <- paste(errMsg, "  >", pkgName, "\n")
  }
  if(allowSrcDownload) {
    errMsg <- paste(errMsg, "Missing sources will be downloaded from CRAN.\n")
    errMsg <- paste(errMsg, "They will be saved under", pkgSrcDir, "\n")
    cat(errMsg)
    # Downloading
    download.packages(missingSrcsReqPkgs, destdir=pkgSrcDir,
                      repos=remoteRepo, type="source")
    cat("Updating local R repo... ")
    tools::write_PACKAGES(dir=pkgSrcDir)
    availablePkgsLocalRepo <- available.packages(repos=localRepo)
    cat("Done.\n")
  } else {
    errMsg <- paste(errMsg,'If you wish the missing sources to be downloaded,\n')
    errMsg <- paste(errMsg,'please run the code with the "--allow-downloads" option.\n')
    errMsg <- paste(errMsg, "You can also manually add the missing package tarballs to the\n")
    errMsg <- paste(errMsg, pkgSrcDir, "\n")
    errMsg <- paste(errMsg, "directory, use R's tools::write_PACKAGES",
                "function to update the repo, and try again.\n"
              )
    stop(errMsg)
  }
}

# Build step
# At this point, sources for all required packages should be available locally
binSearchPaths <- c(localPreCompiledPkgsDir, envVarPreCompiledPkgsDir)
cat("Looking for pre-compiled binaries at:\n")
for(dir in binSearchPaths) cat(paste("  >", dir, "\n"))
binFilePaths <- listBinFiles(binSearchPaths)
if(rebuildAll | length(binFilePaths)==0) {
  binsToBeBuilt <- allPkgs
} else {
  binsToBeBuilt <- c()
  for (pkgName in srcsReqInRepo) {
    pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
    fPath <- pathToBinary(
               pkgName, pkgVer, platform=sysInfoStringShort, 
               fullBinList=binFilePaths
             )
    if(is.na(fPath)) binsToBeBuilt <- c(binsToBeBuilt, pkgName)
  }
}

if(length(binsToBeBuilt)==0) {
  cat("All needed binaries are available. No binaries need to be built.\n")
} else {
  cat("\n")
  cat("The following packages are marked to be built:\n")
  for (pkgName in binsToBeBuilt) {
    cat("  >", pkgName, "\n")
  }
  cat("Total:", length(binsToBeBuilt), "packages to be built.\n")

  cat("\n")
  # If we do not do this, then install.packages may download these pkgs
  cat("Handling eventual pre-compiled but not installed R-pkg dependencies...")
  install_binaries(fPaths=binFilePaths, lib=tmpLibForBuild, overwrite=FALSE)
  cat(" Done.\n")
  cat("Building now...\n")
  # Moving to a tempdir so that the work dir doesn't get full of tarballs
  setwd(tmpDirForBuild)
  for (pkgName in binsToBeBuilt) {
    tryCatch(
      install.packages(pkgName, lib=tmpLibForBuild,
        repos=localRepo, type="source", INSTALL_opts="--build",
        configure.args=c(udunits2='--with-udunits2-include=/usr/include/udunits2')
      ),
      warning = function(w) handleInstallFailure(w, okToProceed=allSuggestsDeps),
      # Copying compiled binaries, so they are available next time
      finally=mvPkgsBinsToRepo(tmpDirForBuild, localPreCompiledPkgsDir)
    )
  }
  # Back to the original dir
  setwd(workDir)
  cat("Build finished.\n")
}
if(buildOnly) {
  cat('Flag "--build" passed. Not installing.\n')
  quit()
}

# Install step
# At this stage, all needed binaries should be available
cat("\n")
cat("R libraries will (if needed) be installed to: ", lib, "\n")
cat("\n")
if(length(pkgsToBeInstalled)==0) {
 cat("The listed packages seem to have already been installed.\n")
 cat("Nothing to do.\n")
 quit()
}

if(length(pkgsToBeUpdated)>0) {
  cat("\n")
  cat("The following packages will be updated:\n")
  for (pkg in pkgsToBeUpdated) {
    cat("  >", pkg, "\n")
  }
  cat("Total:", length(pkgsToBeUpdated), "packages to be updated.\n")
}

binFilePaths <- listBinFiles(binSearchPaths)
for (pkgName in pkgsToBeInstalled) {
  installAction <- "  > Installing"
  if(pkgName %in% pkgsToBeUpdated) installAction <- "  > Updating"
  cat(paste(installAction, " ", pkgName, '... ', sep=""))
  pkgVer <- availablePkgsLocalRepo[pkgName, "Version"]
  preCompPkgPath <- pathToBinary(
                      pkgName, pkgVer, platform=sysInfoStringShort, 
                      fullBinList=binFilePaths
                    )
  install_binaries(fPaths=preCompPkgPath, lib=lib, overwrite=TRUE)
  cat("Done.\n")
}

cat("\n")
cat("Obsmon install script has finished. \n")
