#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly=TRUE)
showDepsAndQuit <- "--listdeps" %in% args
refreshDeps <- "--refreshdeps" %in% args
abortIfMissingNeededSrcs <- "--abort-if-missing-src" %in% args
forceCompiledPkgs <- "--force-compile" %in% args

repo=c("http://cran.ma.imperial.ac.uk/")
lib=Sys.getenv("R_LIBS_USER")
if(lib=="") lib=file.path(Sys.getenv("HOME"), "R", "library")
if(!dir.exists(lib)) dir.create(lib, recursive=TRUE)

platform <- R.Version()$platform
sysName <- 'unknown'
sysRel <- 'unknown'
try(
  {
    sysName <- system2("lsb_release", args=c("-i"), stdout=TRUE, stderr=FALSE)
    sysRel <- system2("lsb_release", args=c("-r"), stdout=TRUE, stderr=FALSE)
    sysName <- strsplit(sysName, ":[[:space:]]*")[[1]][2]
    sysRel <- strsplit(sysRel, ":[[:space:]]*")[[1]][2]
  },
  silent=TRUE
)
sysInfoString <- paste(platform, sysName, sysRel, sep="-")

localRLibDir <- "utils/build/local_R_library"
depsCacheFile <- "utils/build/pkg_dependencies.Rdata"
pkgSrcDir <- paste(localRLibDir, "src", sep="/")
preCompiledPkgsDir <- paste(localRLibDir, "pre_compiled", sysInfoString, sep="/")
if(!dir.exists(pkgSrcDir)) dir.create(pkgSrcDir, recursive=TRUE)
if(!dir.exists(preCompiledPkgsDir)) dir.create(preCompiledPkgsDir, recursive=TRUE)

basePackagesR <- rownames(installed.packages(priority="base"))

dependencies <- function(pkgName, 
  recDepth=0,
  levelOneDepsType=c("Depends", "Imports", "LinkingTo", "Suggests"),
  levelTwoDepsType=c("Depends", "Imports", "LinkingTo"),
  availablePkgs=available.packages(repos=repo), 
  exclude=rownames(installed.packages(priority="base")),
  exclude_from_suggests=c("sf")){
#  Recursively search dependencies if package pkgName.
#
#  pkgName: Package(s) for which dependencies should be searched
#  levelOneDepsType: What type of 1st-order (recursion depth 0) dependencies should be 
#           included in the search
#  levelTwoDepsType: What type of secondary (recursion depth > 0) dependencies 
#                    should be included in the search
#  exclude: Dependencies that should not be included in the return value
#
#  In principle, we should not need to write such a function, given that
#  install.packages is supposed to resolve dependencies (the behaviour 
#  implemented here is in principle equivalent to setting dependencies=TRUE
#  in install.packages). Nonetheless, from our tests on the behaviour of the
#  install.packages method itself (which defaults to recursively installing
#  all dependencies listed under "Depends", "Imports", "LinkingTo" in the 
#  DESCRIPTION files of the main packages to be installed), it seems that
#  that method can yield somewhat erratic results. This function therefore
#  gives us more control over what is to be installed.

  depsType <- levelOneDepsType
  if(recDepth>0) depsType <- levelTwoDepsType
  deps <- unlist(tools::package_dependencies(pkgName, db=availablePkgs,
                          which=depsType,
                          recursive=FALSE
                        )
          )
  deps <- deps[!(deps %in% exclude)]

  if(length(deps)==0) {
    return(character(0))
  } else {
    if(("Suggests" %in% depsType) && length(exclude_from_suggests)>0) {
      # Some "Suggests" dependencies may be problematic, and it may be better to
      # accept the risk of removing them than having to solve issues related to
      # system dependencies. The "sf" package is one of such cases at SMHI/LINDA.
      suggestsTypeDeps <- unlist(tools::package_dependencies(pkgName,
                                          db=availablePkgs,
                                          which=c("Suggests"),
                                          recursive=FALSE
                                        )
                          )
      sugDeps2BDel <- suggestsTypeDeps[suggestsTypeDeps %in% exclude_from_suggests]
      deps <- deps[!(deps %in% sugDeps2BDel)]
    }

    deps <- unique(c(dependencies(deps, recDepth=recDepth+1), deps))
    return(deps)
  }
}

cat('Gathering packages used in the ".R" files in current dir and subdirs...')
# These may have been imported explicitly using "library" or "require",
# or used without explicit import (as in "myLib::myFunction").
allRFiles <- list.files(pattern=".R$", recursive=TRUE)
pattParentheses <- "[[:space:]]*\\(+[[:space:]]*.+[[:space:]]*\\)"
pattLib <- paste("library+", pattParentheses, sep='')
pattReq <- paste("require+", pattParentheses, sep='')
patDubColon <- "[[:alpha:]]+\\w*[[:space:]]*::"
importedPkgs <- c()
doubleColonPkgs <- c()
for (file in allRFiles) {
  fLines <- readLines(file)
  importedPkgs <- c(importedPkgs, grep(pattLib, fLines, value=TRUE))
  importedPkgs <- c(importedPkgs, grep(pattReq, fLines, value=TRUE))
  doubleColonPkgs <- c(doubleColonPkgs, grep(patDubColon, fLines, value=TRUE))
}
# Keeping only package names (i.e., no punctuation, white spaces etc.)
importedPkgs <- unique(
  gsub("[\\(\\)[:space:]]", "", 
    regmatches(importedPkgs, gregexpr("\\(.*?\\)", importedPkgs))
  )
)
doubleColonPkgs <- unique(
  gsub("[:[:space:]]", "", 
    regmatches(doubleColonPkgs, gregexpr(patDubColon, doubleColonPkgs))
  )
)

# Finally building the list of main packages used.
# Dependencies are not yet considered at this stage.
mainPkgs <- c(importedPkgs, doubleColonPkgs)
mainPkgs <- sort(unique(mainPkgs[!(mainPkgs %in% basePackagesR)]))

cat("Done.\n  > The following",length(mainPkgs),"main packages were found:\n")
for (pkg in mainPkgs) {
  cat("    *", pkg, "\n")
}

cat("\n")
cat("Getting recursive dependency list: \n") 
# Doing this manually because we've had too many problems with somewhat erratic
# behaviour of the install.packages own dependency resolution
# First, attempt to read cached dependencies to avoid checking online
pkgsDeps <- list()
if(file.exists(depsCacheFile)) {
  pkgsDeps <- readRDS(depsCacheFile)
}
recursiveDepsOfMainPkgs <- c()
for (pkg in mainPkgs) {
  cat("  >", pkg, "... ")
  if(refreshDeps || !(pkg %in% names(pkgsDeps))) {
    deps <- dependencies(pkg)
    pkgsDeps[[pkg]] <- deps
  } else {
    deps <- pkgsDeps[[pkg]]
  }
  newDeps <- setdiff(deps, intersect(deps,c(mainPkgs,recursiveDepsOfMainPkgs)))
  cat("nDependencies =", length(deps), "(", length(newDeps),"new)\n")
  recursiveDepsOfMainPkgs <- c(recursiveDepsOfMainPkgs, deps)
}
saveRDS(pkgsDeps, file=depsCacheFile)

# At last, building the full list of pkgs to be installed
pkgs <- unique(c(recursiveDepsOfMainPkgs, mainPkgs))

cat("\n")
cat("The following pkgs should be available after a successful full install:\n")
for (pkg in sort(pkgs)) {
  cat("  >", pkg, "\n")
}
cat("Total:", length(pkgs), "packages.\n \n")

if(showDepsAndQuit) {
  cat('Option "--listdeps" passed. Not installing packages. \n')
  cat('Stopping now.\n')
  quit()
}

# Installation
installedPkgs <- installed.packages(lib.loc=lib)[,1]

preCompPkgsCopied <- FALSE
if(forceCompiledPkgs) {
  cat('Flag "--force-compile" found. Compiling all packages.\n')
  newPkgs <- pkgs
} else {
  # Copying pre-compiled packages to the library, if not already installed
  preCompiledPkgs <- list.files(preCompiledPkgsDir, pattern="\\.tar\\.gz$|\\.tgz$")
  for (preCompPkg in preCompiledPkgs) {
    pkgName <- strsplit(preCompPkg, split="\\.tar\\.gz$|\\.tgz$")[[1]]
    preCompPkgPath <- paste(preCompiledPkgsDir, preCompPkg, sep="/")
    if(!(pkgName %in% installedPkgs)) {
      cat(paste('Found pre-compiled pkg "', pkgName, 
            '". Copying to the library... ', sep='')
      )
      utils::untar(preCompPkgPath, exdir=lib, compressed=TRUE)
      cat("Done \n")
      preCompPkgsCopied <- TRUE
    }
  }  
  # installedPkgs now needs to be updated
  installedPkgs <- installed.packages(lib.loc=lib)[,1]
  newPkgs <- pkgs[!(pkgs %in% installedPkgs)]
}

if(length(newPkgs)==0) {
  if(preCompPkgsCopied) {
    cat("\n")
    cat("No further packages need to be compiled. Installation finished. \n")
  } else {
    cat("The listed packages seem to have already been installed.\n")
    cat("Nothing to do.\n")
  }
  quit()
} else {
  cat("\n")
  cat("The following packages are marked for compilation:\n")
  for (pkg in newPkgs) {
    cat("  >", pkg, "\n")
  }
  cat("Total:", length(newPkgs), "new packages.\n")
}

srcsAvailable <- list.files(pkgSrcDir, pattern="\\.tar\\.gz$|\\.tgz$")
# Checking whether sources files for newPkgs are missing
newPkgsWithMissingSrcs <- c()
for (pkg in newPkgs) {
  patt <- paste("^", pkg, "\\_", sep="")
  matchIndices <- grep(patt, srcsAvailable)
  if(length(matchIndices)==0) {
    newPkgsWithMissingSrcs <- c(newPkgsWithMissingSrcs, pkg)
  }
}

# Deciding whether or not to download needed source files that are missing.
# The default is to download them. This is to keep backwards compatibility.
# It is preferrable, however, to have them downloaded and verified in a secure
# computer, and then moved to pkgSrcDir once they are considered safe.
# Use the "--abort-if-missing-src" command line option if you want the install
# script to abort if sources are not available locally. 
if(length(newPkgsWithMissingSrcs)>0) {
  if(abortIfMissingNeededSrcs) {
    errMsg <- paste("The source files for following packages are missing:\n")
    for (pkg in newPkgsWithMissingSrcs) {
      errMsg <- paste(errMsg, "  >", pkg, "\n")
    }
    errMsg <- paste(errMsg,
                "Please add them to the", pkgSrcDir, 
                "directory and try again.\n"
              )
    stop(errMsg)
  } else {
    download.packages(newPkgsWithMissingSrcs, destdir=pkgSrcDir, 
                      repos=repo, type="source")
    # Refreshing list of available src files
    srcsAvailable <- list.files(pkgSrcDir, pattern="\\.tar\\.gz$|\\.tgz$")
  }
}

srcsToBeCompiled <- c()
for (pkg in newPkgs) {
  patt <- paste("^", pkg, "\\_", sep="")
  matchIndices <- grep(patt, srcsAvailable)
  srcsToBeCompiled <- c(srcsToBeCompiled, srcsAvailable[matchIndices])
}

if(length(srcsToBeCompiled)>0) {
  srcsToBeCompiledFullPath <- paste(pkgSrcDir, srcsToBeCompiled, sep="/")
  withCallingHandlers(
    install.packages(srcsToBeCompiledFullPath, lib=lib, repos=NULL, type="source"),
    warning = function(w) stop(w)
  )
}

cat("Obsmon install script has finished. \n")
