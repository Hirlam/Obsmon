#!/usr/bin/env Rscript

args <- commandArgs(trailingOnly=TRUE)
showDepsAndQuit <- "--listdeps" %in% args
refreshDeps <- "--refreshdeps" %in% args
abortIfMissingNeededSrcs <- "--abort-if-missing-src" %in% args
forceCompiledPkgs <- "--force-compile" %in% args

includeDirR <- file.path("utils", "build", "include", "R")
source(file.path(includeDirR, "getSysInfo.R"))
source(file.path(includeDirR, "dependencies.R"))
source(file.path(includeDirR, "getExplicitlyUsedRPkgs.R"))

repo=c("http://cran.ma.imperial.ac.uk/")
lib=Sys.getenv("R_LIBS_USER")
if(lib=="") lib=file.path(Sys.getenv("HOME"), "R", "library")
if(!dir.exists(lib)) dir.create(lib, recursive=TRUE)

sysInfoString <- getSysInfo()

localRLibDir <- "utils/build/local_R_library"
depsCacheFile <- "utils/build/pkg_dependencies.Rdata"
pkgSrcDir <- paste(localRLibDir, "src", sep="/")
preCompiledPkgsDir <- paste(localRLibDir, "pre_compiled",
                        sysInfoString, sep="/"
                      )
for (dir in c(pkgSrcDir, preCompiledPkgsDir)) {
  if(!dir.exists(dir)) dir.create(dir, recursive=TRUE)
}

cat('Gathering packages used in the ".R" files in current dir and subdirs...')
# These may have been imported explicitly using "library" or "require",
# or used without explicit import (double-colon syntax).
allRFiles <- list.files(pattern=".R$", recursive=TRUE)
mainPkgs <- getExplicitlyUsedRPkgs(allRFiles)

cat("Done.\n  > The following",length(mainPkgs),"main packages were found:\n")
for (pkg in mainPkgs) {
  cat("    *", pkg, "\n")
}

cat("\n")
cat("Getting recursive dependency list: \n")
# Doing this manually because we've had too many problems with somewhat erratic
# behaviour of the install.packages own dependency resolution
# First, attempt to read cached dependencies to avoid checking online
pkgsDeps <- list()
if(file.exists(depsCacheFile)) {
  pkgsDeps <- readRDS(depsCacheFile)
}
# Having separate lists with the names of essencial packages and packages that
# are only needed as "Suggests"-type dependencies (and recursive dependencies
# of these) will allow us, later on, to decide what to do in case a package
# fails to be installed
allEssencialDeps <- c()
allSuggestsDeps <- c()
allPkgDeps <- c()
essentialDepsTypes <- c("Depends", "Imports", "LinkingTo")
for (pkg in mainPkgs) {
  cat("  >", pkg, "... ")
  if(refreshDeps || !(pkg %in% names(pkgsDeps))) {
    availablePkgs <- available.packages(repos=repo)
    essencialDeps <- dependencies(pkg, db=availablePkgs,
                       levelOneDepsType=essentialDepsTypes
                     )
    suggestsDeps <- dependencies(pkg, db=availablePkgs,
                      levelOneDepsType="Suggests"
                    )
    # A Suggests type dependency may also end up being a recursive non-suggests
    # dependency of the essencial packages. We don't want to have these
    # considered as optional.
    suggestsDeps <- suggestsDeps[!(suggestsDeps %in% essencialDeps)]
    pkgsDeps[[pkg]] <- list(essencial=essencialDeps, Suggests=suggestsDeps)
  }
  thisPkgDeps <-c(pkgsDeps[[pkg]][["essencial"]],pkgsDeps[[pkg]][["Suggests"]])
  newDeps <-setdiff(thisPkgDeps,intersect(thisPkgDeps,c(mainPkgs, allPkgDeps)))
  cat("nDependencies =", length(thisPkgDeps), "(", length(newDeps),"new)\n")
  allEssencialDeps <- c(allEssencialDeps, pkgsDeps[[pkg]][["essencial"]])
  allSuggestsDeps <- c(allSuggestsDeps, pkgsDeps[[pkg]][["Suggests"]])
  allPkgDeps <- c(allPkgDeps, allEssencialDeps, allSuggestsDeps)
}
saveRDS(pkgsDeps, file=depsCacheFile)

# At last, building the full list of pkgs to be installed
pkgs <- unique(c(allPkgDeps, mainPkgs))
allEssencialDeps <- unique(allEssencialDeps[!(allEssencialDeps %in% mainPkgs)])
allSuggestsDeps <- unique(
                     allSuggestsDeps[
                       !(allSuggestsDeps %in% c(allEssencialDeps, mainPkgs))
                     ]
                   )

cat("\n")
msg <- "In addition to the main packages listed above,"
msg <- paste(msg, "the following dependencies should also", sep=" ")
msg <- paste(msg, "be available after a successful full install:\n", sep="\n")
cat(msg)
cat("* Essencial dependencies:\n")
for (pkg in sort(allEssencialDeps)) {
  cat("  >", pkg, "\n")
}
cat("* Suggests-type dependencies:\n")
for (pkg in sort(allSuggestsDeps)) {
  cat("  >", pkg, "\n")
}
cat("Total:", length(pkgs), "packages.\n")
cat("  Main packages:", length(mainPkgs), "\n")
cat("  Essencial dependencies:", length(allEssencialDeps), "\n")
cat("  Suggests-type dependencies:", length(allSuggestsDeps), "\n")
cat("\n")

if(showDepsAndQuit) {
  cat('Option "--listdeps" passed. Not installing packages. \n')
  cat('Stopping now.\n')
  quit()
}

# Installation
installedPkgs <- installed.packages(lib.loc=lib)[,1]

preCompPkgsCopied <- FALSE
if(forceCompiledPkgs) {
  cat('Flag "--force-compile" found. Compiling all packages.\n')
  newPkgs <- pkgs
} else {
  # Copying pre-compiled packages to the library, if not already installed
  preCompiledPkgs <- list.files(preCompiledPkgsDir,
                       pattern="\\.tar\\.gz$|\\.tgz$"
                     )
  for (preCompPkg in preCompiledPkgs) {
    pkgName <- strsplit(preCompPkg, split="\\.tar\\.gz$|\\.tgz$")[[1]]
    preCompPkgPath <- paste(preCompiledPkgsDir, preCompPkg, sep="/")
    if(!(pkgName %in% installedPkgs)) {
      cat(paste('Found pre-compiled pkg "', pkgName,
            '". Copying to the library... ', sep='')
      )
      utils::untar(preCompPkgPath, exdir=lib, compressed=TRUE)
      cat("Done \n")
      preCompPkgsCopied <- TRUE
    }
  }
  # installedPkgs now needs to be updated
  installedPkgs <- installed.packages(lib.loc=lib)[,1]
  newPkgs <- pkgs[!(pkgs %in% installedPkgs)]
}

if(length(newPkgs)==0) {
  if(preCompPkgsCopied) {
    cat("\n")
    cat("No further packages need to be compiled. Installation finished. \n")
  } else {
    cat("The listed packages seem to have already been installed.\n")
    cat("Nothing to do.\n")
  }
  quit()
} else {
  cat("\n")
  cat("The following packages are marked for compilation:\n")
  for (pkg in newPkgs) {
    cat("  >", pkg, "\n")
  }
  cat("Total:", length(newPkgs), "new packages.\n")
}

srcsAvailable <- list.files(pkgSrcDir, pattern="\\.tar\\.gz$|\\.tgz$")
# Checking whether sources files for newPkgs are missing
newPkgsWithMissingSrcs <- c()
for (pkg in newPkgs) {
  patt <- paste("^", pkg, "\\_", sep="")
  matchIndices <- grep(patt, srcsAvailable)
  if(length(matchIndices)==0) {
    newPkgsWithMissingSrcs <- c(newPkgsWithMissingSrcs, pkg)
  }
}

# Deciding whether or not to download needed source files that are missing.
# The default is to download them. This is to keep backwards compatibility.
# It is preferrable, however, to have them downloaded and verified in a secure
# computer, and then moved to pkgSrcDir once they are considered safe.
# Use the "--abort-if-missing-src" command line option if you want the install
# script to abort if sources are not available locally.
if(length(newPkgsWithMissingSrcs)>0) {
  if(abortIfMissingNeededSrcs) {
    errMsg <- paste("The source files for following packages are missing:\n")
    for (pkg in newPkgsWithMissingSrcs) {
      errMsg <- paste(errMsg, "  >", pkg, "\n")
    }
    errMsg <- paste(errMsg,
                "Please add them to the", pkgSrcDir,
                "directory and try again.\n"
              )
    stop(errMsg)
  } else {
    download.packages(newPkgsWithMissingSrcs, destdir=pkgSrcDir,
                      repos=repo, type="source")
    # Refreshing list of available src files
    srcsAvailable <- list.files(pkgSrcDir, pattern="\\.tar\\.gz$|\\.tgz$")
  }
}

srcsToBeCompiled <- c()
for (pkg in newPkgs) {
  patt <- paste("^", pkg, "\\_", sep="")
  matchIndices <- grep(patt, srcsAvailable)
  srcsToBeCompiled <- c(srcsToBeCompiled, srcsAvailable[matchIndices])
}

handleInstallFailure <- function(callAndErrorMsg, okToProceed=allSuggestsDeps){
  # 'Warning' function to be used along with "withCallingHandlers" when calling
  # install.packages. The function will only issue warnings "Suggests"-type
  # dependencies fail to be installed, but will stop installation if any falure
  # occurs with the other types of dependencies.
  msg <- callAndErrorMsg[["message"]]
  pattBackticks <- "‘+.+’+"
  offendingFile <- gsub("‘*’*", "",
                     regmatches(msg, gregexpr(pattBackticks, msg))
                   )
  offendingPkg <- grep("\\.tar\\.gz$|\\.tgz$",
                    unlist(strsplit(offendingFile, split="/")),
                    value=TRUE
                  )
  offendingPkg <- gsub("_.+\\.tar\\.gz$|_.+\\.tgz$", "", offendingPkg)
  if(offendingPkg %in% okToProceed) {
    warning(callAndErrorMsg)
  } else {
    stop(callAndErrorMsg)
  }
}

if(length(srcsToBeCompiled)>0) {
  srcsToBeCompiledFullPath <- paste(pkgSrcDir, srcsToBeCompiled, sep="/")
  withCallingHandlers(
    install.packages(srcsToBeCompiledFullPath, lib=lib,
      repos=NULL, type="source"
    ),
    warning = function(w) handleInstallFailure(w)
  )
}

cat("Obsmon install script has finished. \n")
