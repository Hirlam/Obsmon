#!/usr/bin/env Rscript
# argv contains the raw vector of arguments passed to the script
# The parsing of the arguments will be performed later
argv <- commandArgs(trailingOnly = FALSE)

# Flagging whether that obsmon is being run as a standalone application, i.e.,
# not within a shiny server
runningAsStandalone <- TRUE

# Changing work dir to obsmonSrcDir, so all needed files can be found
dirObsmonWasCalledFrom <- getwd()
thisFilePath <- normalizePath(sub("--file=", "", argv[grep("--file=", argv)]))
# Accounting for the fact that the script may be executed via a symlink
obsmonSrcDir <- dirname(Sys.readlink(thisFilePath))
if(obsmonSrcDir=="" || anyNA(obsmonSrcDir)) obsmonSrcDir<-dirname(thisFilePath)
setwd(obsmonSrcDir)

# Printing startup info such as code name, version and git info
source("src/src_info_obsmon.R")
cat(obsmonBanner)
cat("Initializing Obsmon...\n")

# Configuring libPaths
# We will do this here instead of inside init.R because we need this to be able to
# load argparse, which is used when running this executable, but not used when
# running in a shiny server
source('src/lib_paths_config.R')

# Parsing command line arguments
tryCatch(
  {
    suppressPackageStartupMessages(library(argparse))
    cat('For a list of available options, please use the "-h" argument.\n\n')
  },
  error=function(e) stop(paste(e, libPathsMsg[['error']], sep="\n"))
)
parser <- ArgumentParser()
parser$add_argument("--launch", action="store_true", help="Launch browser")
parser$add_argument('-pt', '--port', type="integer", default=5391,
  help=paste('Port the app will listen to (default: 5391).',
         'If busy, the code will attempt to pick a valid port number randomly'
       )
)
parser$add_argument("--debug", action="store_true", help="Start in debug mode")
parser$add_argument("--batch", action="store_true", help="Run in batch mode")
cmdLineArgs <- parser$parse_args()

# Initialising the rest of the code
source("src/init.R")

status <- runObsmonStandAlone(cmdLineArgs)
